"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const errors_1 = require("@oclif/errors");
const plugin_help_1 = tslib_1.__importDefault(require("@oclif/plugin-help"));
const command_1 = tslib_1.__importDefault(require("@oclif/plugin-help/lib/command"));
const list_1 = require("@oclif/plugin-help/lib/list");
const util_1 = require("@oclif/plugin-help/lib/util");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const indent_string_1 = tslib_1.__importDefault(require("indent-string"));
const strip_ansi_1 = tslib_1.__importDefault(require("strip-ansi"));
const wrap_ansi_1 = tslib_1.__importDefault(require("wrap-ansi"));
const tree_1 = tslib_1.__importDefault(require("../tree"));
const { bold } = chalk_1.default;
exports.init = async function (ctx) {
    // build tree
    const cmds = [
        ...ctx.config.commandIDs,
        ...ctx.config.commands.reduce((acum, command) => {
            acum.push(...command.aliases);
            return acum;
        }, []),
    ];
    const tree = new tree_1.default();
    cmds.forEach((c) => {
        const bits = c.split(':');
        let cur = tree;
        bits.forEach((b) => {
            cur = cur.findOrInsert(b);
        });
    });
    const id = (typeof ctx.id === 'string' ? [ctx.id] : ctx.id) || [];
    const RAWARGV = id.concat(ctx.argv || []);
    const convertName = function (cmdId) {
        return cmdId.join(':');
    };
    const convertArgv = function (cmdId, old = process.argv) {
        const keys = cmdId.split(':');
        const argv = old.slice(keys.length + 2, old.length);
        return argv;
    };
    // overwrite config.findCommand
    const { findCommand } = ctx.config;
    function spacesFindCommand(_, __) {
        const [node, c] = tree.findMostProgressiveCmd(RAWARGV);
        if (node) {
            if (Object.keys(node.nodes).length)
                return;
            return findCommand.apply(ctx.config, [convertName(c)]);
        }
    }
    ctx.config.findCommand = spacesFindCommand;
    // overwrite commandHelp.defaultUsage
    // @ts-ignore
    command_1.default.prototype.defaultUsage = function (_) {
        return util_1.compact([
            this.command.id.replace(':', ' '),
            this.command.args
                .filter((a) => !a.hidden)
                .map((a) => this.arg(a))
                .join(' '),
        ]).join(' ');
    };
    // overwrite config.findTopic
    const { findTopic } = ctx.config;
    function spacesFindTopic(_, __) {
        const [node, c] = tree.findMostProgressiveCmd(RAWARGV);
        if (node) {
            return findTopic.apply(ctx.config, [convertName(c)]);
        }
    }
    ctx.config.findTopic = spacesFindTopic;
    // overwrite config.runCommand
    ctx.config.runCommand = async (cmdId, argv = []) => {
        const originalId = cmdId;
        // tslint:disable-next-line:no-unused
        const [_, name] = tree.findMostProgressiveCmd(RAWARGV);
        // override the id b/c of the closure
        cmdId = name.join(' ');
        argv = convertArgv(name.join(':'));
        // don't need to pass ID b/c of the closure
        const c = ctx.config.findCommand('');
        if (!c) {
            await ctx.config.runHook('command_not_found', { id: cmdId });
            throw new errors_1.CLIError(`command ${originalId} not found`);
        }
        const command = c.load();
        await ctx.config.runHook('prerun', { Command: command, argv });
        await command.run(argv, ctx.config);
    };
    // overwrite Help#topics
    plugin_help_1.default.prototype.topics = function (topics) {
        if (!topics.length)
            return;
        const body = list_1.renderList(topics.map((c) => [c.name.replace(/:/g, ' '), c.description && this.render(c.description.split('\n')[0])]), {
            spacer: '\n',
            stripAnsi: this.opts.stripAnsi,
            maxWidth: this.opts.maxWidth - 2,
        });
        return [bold('COMMANDS'), indent_string_1.default(body, 2)].join('\n');
    };
    // overwrite Help#topic
    plugin_help_1.default.prototype.topic = function (topic) {
        let description = this.render(topic.description || '');
        const title = description.split('\n')[0];
        description = description.split('\n').slice(1).join('\n');
        let output = util_1.compact([
            title,
            [
                bold('USAGE'),
                indent_string_1.default(wrap_ansi_1.default(`$ ${this.config.bin} ${topic.name.replace(/:/g, ' ')} COMMAND`, this.opts.maxWidth - 2, {
                    trim: false,
                    hard: true,
                }), 2),
            ].join('\n'),
            description &&
                [
                    bold('DESCRIPTION'),
                    indent_string_1.default(wrap_ansi_1.default(description, this.opts.maxWidth - 2, {
                        trim: false,
                        hard: true,
                    }), 2),
                ].join('\n'),
        ]).join('\n\n');
        if (this.opts.stripAnsi)
            output = strip_ansi_1.default(output);
        return `${output}\n`;
    };
    command_1.default.prototype.generate = function () {
        const cmd = this.command;
        const flags = util_1.sortBy(Object.entries(cmd.flags || {})
            .filter(([, v]) => !v.hidden)
            .map(([k, v]) => {
            v.name = k;
            return v;
        }), (f) => [!f.char, f.char, f.name]);
        const args = (cmd.args || []).filter((a) => !a.hidden);
        let output = util_1.compact([
            this.usage(flags),
            this.args(args),
            this.flags(flags),
            this.description(),
            this.aliases(cmd.aliases.map((alias) => alias.replace(/:/g, ' '))),
            this.examples(cmd.examples || cmd.example),
        ]).join('\n\n');
        if (this.opts.stripAnsi)
            output = strip_ansi_1.default(output);
        return output;
    };
};
