"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const treeify_1 = tslib_1.__importDefault(require("treeify"));
class Tree {
    constructor() {
        this.nodes = {};
    }
    insert(child, value = new Tree()) {
        this.nodes[child] = value;
        return this;
    }
    childSearch(key) {
        const k = Object.keys(this.nodes).find((kk) => kk === key);
        return k ? this.nodes[k] : undefined;
    }
    // progressiveChildSearch(keys: string[], tree = this): Tree | undefined {
    //   let cur: Tree | undefined = tree.childSearch(keys[0])
    //   if (!cur) return
    //   if (!keys[1]) return cur
    //   return cur.progressiveChildSearch(keys.slice(1, keys.length), cur)
    // }
    findOrInsert(child, value = new Tree()) {
        const c = this.childSearch(child);
        if (c)
            return c;
        this.insert(child, value);
        return this.childSearch(child);
    }
    // tslint:disable-next-line:no-console
    display(logger = console.log) {
        const addNodes = function (nodes) {
            const tree = {};
            for (const p of Object.keys(nodes)) {
                tree[p] = addNodes(nodes[p].nodes);
            }
            return tree;
        };
        const tree = addNodes(this.nodes);
        logger(treeify_1.default.asTree(tree));
    }
}
class CommandTree extends Tree {
    findMostProgressiveCmd(id) {
        let cur;
        let next;
        for (let i = 0; i < id.length; i++) {
            next = (next || this).nodes[id[i]];
            if (!next)
                return [cur, !i ? [] : id.slice(0, i)];
            cur = next;
        }
        return [cur, id];
    }
}
exports.default = CommandTree;
