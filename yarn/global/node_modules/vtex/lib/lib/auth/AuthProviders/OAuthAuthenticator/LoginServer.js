"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoginServer = void 0;
const tslib_1 = require("tslib");
const async_retry_1 = tslib_1.__importDefault(require("async-retry"));
const co_body_1 = tslib_1.__importDefault(require("co-body"));
const detect_port_1 = tslib_1.__importDefault(require("detect-port"));
const koa_1 = tslib_1.__importDefault(require("koa"));
const logger_1 = tslib_1.__importDefault(require("../../../../api/logger"));
const ErrorKinds_1 = require("../../../../api/error/ErrorKinds");
const VTEXID_1 = require("../../../../api/clients/IOClients/external/VTEXID");
const ErrorReport_1 = require("../../../../api/error/ErrorReport");
const SUCCESS_PAGE = `
<!doctype html>
<html>
  <head>
    <title>Success</title>
    <meta charset="utf-8">
  </head>
  <body>
    <p> Você já pode fechar essa janela. </p>
    <p> You may now close this window. </p>
    <p> Ahora puedes cerrar esta ventana. </p>
  </body>
</html>`;
class LoginServer {
    constructor(loginConfig) {
        this.loginConfig = loginConfig;
        this.app = new koa_1.default();
        this.registerLoginHandler();
        this.tokenPromise = new Promise((resolve, reject) => {
            this.resolveTokenPromise = resolve;
            this.rejectTokenPromise = reject;
        });
    }
    static async create(loginConfig) {
        const loginServer = new LoginServer(loginConfig);
        await loginServer.start();
        return loginServer;
    }
    get token() {
        return this.tokenPromise;
    }
    get loginCallbackUrl() {
        if (!this.port) {
            throw new Error('LoginServer not initialized');
        }
        return `http://${LoginServer.HOSTNAME}:${this.port}${LoginServer.LOGIN_CALLBACK_PATH}`;
    }
    setLoginState(val) {
        this.loginState = val;
    }
    start() {
        return async_retry_1.default(async (bail, attemptNumber) => {
            try {
                // detectPort will get the specified port or, if it's in use, another ramdom unnused port
                this.port = await detect_port_1.default(3000);
                this.server = await this.initServer(this.port);
                logger_1.default.debug(`LoginServer started on http://${LoginServer.HOSTNAME}:${this.port}`);
            }
            catch (err) {
                logger_1.default.debug(`LoginServer failed to start on port:${this.port}. Reason: ${err.message}.`);
                if (err.code !== 'EADDRINUSE') {
                    return bail(err);
                }
                if (attemptNumber < LoginServer.SERVER_START_RETRIES + 1) {
                    logger_1.default.debug(`Retrying to start LoginServer...`);
                }
                throw ErrorReport_1.ErrorReport.createAndMaybeRegisterOnTelemetry({
                    originalError: err,
                    kind: ErrorKinds_1.ErrorKinds.LOGIN_SERVER_START_ERROR,
                    details: { attemptNumber },
                });
            }
        }, { retries: LoginServer.SERVER_START_RETRIES, maxTimeout: 100, minTimeout: 100 });
    }
    close() {
        this.server.unref();
        this.server.close();
    }
    initServer(port) {
        return new Promise((resolve, reject) => {
            const server = this.app.listen(port, LoginServer.HOSTNAME, () => {
                server.on('connection', socket => {
                    socket.unref();
                });
                server.removeListener('error', reject);
                resolve(server);
            });
            server.on('error', reject);
        });
    }
    registerLoginHandler() {
        this.app.use(async (ctx) => {
            var _a;
            ctx.set('connection', 'close');
            if (ctx.path !== LoginServer.LOGIN_CALLBACK_PATH) {
                ctx.status = 404;
                ctx.body = 'Not found';
                return;
            }
            ctx.socket.ref();
            logger_1.default.debug(`Received ${ctx.method} login callback`);
            if (!this.loginState) {
                return this.handleError(ctx, new Error('Received login callback before setting login state'));
            }
            if (ctx.method.toLowerCase() === 'options') {
                ctx.set('Access-Control-Allow-Origin', '*');
                ctx.status = 200;
                return;
            }
            let body;
            if (ctx.method.toLowerCase() === 'post') {
                try {
                    body = await co_body_1.default(ctx.req);
                }
                catch (err) {
                    return this.handleError(ctx, err);
                }
            }
            else {
                body = { ott: (_a = ctx.query) === null || _a === void 0 ? void 0 : _a.ott };
            }
            if (!body.ott) {
                return this.handleError(ctx, new Error('Missing ott on VTEX ID callback call'), { body });
            }
            const vtexId = VTEXID_1.VTEXID.createClient({ account: this.loginConfig.account });
            try {
                const { token } = await vtexId.validateToolbeltLogin({
                    account: this.loginConfig.account,
                    secret: this.loginConfig.secret,
                    ott: body.ott,
                    state: this.loginState,
                });
                this.resolveTokenPromise(token);
                ctx.status = 200;
                ctx.set('content-type', 'text/html');
                ctx.body = SUCCESS_PAGE;
            }
            catch (err) {
                return this.handleError(ctx, err);
            }
        });
    }
    handleError(ctx, err, details) {
        const errReport = ErrorReport_1.ErrorReport.createAndMaybeRegisterOnTelemetry({ originalError: err, details });
        ctx.status = 500;
        ctx.body = {
            errorId: errReport.metadata.errorId,
            message: errReport.message,
        };
        this.rejectTokenPromise(errReport);
    }
}
exports.LoginServer = LoginServer;
LoginServer.LOGIN_CALLBACK_PATH = '/login_callback';
LoginServer.SERVER_START_RETRIES = 1;
LoginServer.HOSTNAME = '127.0.0.1';
