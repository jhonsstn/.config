"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const install_1 = tslib_1.__importDefault(require("../../../modules/apps/install"));
const utils_1 = require("../../error/utils");
const Sponsor_1 = require("../../clients/IOClients/apps/Sponsor");
const SessionManager_1 = require("../../session/SessionManager");
const logger_1 = tslib_1.__importDefault(require("../../logger"));
const utils_2 = require("../utils");
const switch_1 = require("../auth/switch");
const prompts_1 = require("../prompts");
const promptSwitchToAccount = async (account, initial) => {
    const reason = initial
        ? `Initial edition can only be set by ${chalk_1.default.blue(account)} account`
        : `Only current account sponsor (${chalk_1.default.blue(account)}) can change its edition`;
    const proceed = await prompts_1.promptConfirm(`${reason}. Do you want to switch to account ${chalk_1.default.blue(account)}?`);
    if (!proceed) {
        return false;
    }
    await switch_1.switchAccount(account, {});
    return true;
};
const confirmAndSwitchEnvironment = async (sponsorAccount, targetAccount, targetWorkspace) => {
    if (!sponsorAccount) {
        if (targetWorkspace !== 'master') {
            throw utils_1.createFlowIssueError('Can only set initial edition in master workspace');
        }
        return promptSwitchToAccount('vtex', true);
    }
    const workspaceIsOk = targetWorkspace !== 'master' || (await utils_2.promptWorkspaceMaster(targetAccount));
    if (!workspaceIsOk)
        return false;
    return promptSwitchToAccount(sponsorAccount, false);
};
const tenantProvisionerApp = 'vtex.tenant-provisioner';
const promptInstallTenantProvisioner = async (account) => {
    logger_1.default.warn(`Tenant provisioner app seems not to be installed in sponsor account ${chalk_1.default.blue(account)}.`);
    const proceed = await prompts_1.promptConfirm(`Do you want to install ${chalk_1.default.blue(tenantProvisionerApp)} in account ${chalk_1.default.blue(account)} now?`);
    if (!proceed) {
        return false;
    }
    await install_1.default([tenantProvisionerApp], { force: false });
    return true;
};
const isProvisionerNotInstalledError = (err) => {
    var _a, _b;
    const res = err.response;
    return (res === null || res === void 0 ? void 0 : res.status) === 404 && ((_a = res.data) === null || _a === void 0 ? void 0 : _a.source) === 'Vtex.Kube.Router' && ((_b = res.data) === null || _b === void 0 ? void 0 : _b.code) === 'NotFound';
};
const trySetEditionOnce = async (client, targetAccount, targetWorkspace, edition) => {
    try {
        await client.setEdition(targetAccount, targetWorkspace, edition);
        return true;
    }
    catch (err) {
        if (!isProvisionerNotInstalledError(err)) {
            throw err;
        }
        return false;
    }
};
const maxSetEditionRetries = 3;
const trySetEdition = async (sponsorAccount, targetAccount, targetWorkspace, edition) => {
    const client = Sponsor_1.Sponsor.createClient();
    let success = await trySetEditionOnce(client, targetAccount, targetWorkspace, edition);
    if (success) {
        return true;
    }
    const installed = await promptInstallTenantProvisioner(sponsorAccount);
    if (!installed) {
        return false;
    }
    const workspaceNotice = targetWorkspace === 'master' ? '' : `in workspace ${chalk_1.default.blue(targetWorkspace)} `;
    logger_1.default.info(`Now setting edition ${chalk_1.default.blue(edition)} ${workspaceNotice}of account ${chalk_1.default.blue(targetAccount)}...`);
    // Retry a couple of times since it might take some time for the installation to propagate until the route is available.
    /* eslint-disable no-await-in-loop */
    for (let retry = 1; !success && retry <= maxSetEditionRetries; retry++) {
        await utils_2.sleepSec(1.5 * retry);
        success =
            retry < maxSetEditionRetries
                ? await trySetEditionOnce(client, targetAccount, targetWorkspace, edition)
                : await client.setEdition(targetAccount, targetWorkspace, edition).then(() => true);
    }
    /* eslint-enable no-await-in-loop */
    return success;
};
async function setEdition(edition, workspace, autoSwitchBack = false) {
    const session = SessionManager_1.SessionManager.getSingleton();
    const { account: previousAccount, workspace: previousWorkspace } = session;
    const targetAccount = session.account;
    const targetWorkspace = workspace !== null && workspace !== void 0 ? workspace : session.workspace;
    const workspaceNotice = targetWorkspace === 'master' ? '' : ` in workspace ${chalk_1.default.blue(targetWorkspace)}`;
    logger_1.default.info(`Changing edition of account ${chalk_1.default.blue(targetAccount)}${workspaceNotice}.`);
    const sponsorClient = Sponsor_1.Sponsor.createClient();
    const sponsorAccount = await sponsorClient.getSponsorAccount();
    const switched = await confirmAndSwitchEnvironment(sponsorAccount, targetAccount, targetWorkspace);
    if (!switched) {
        return;
    }
    try {
        if (!(await trySetEdition(sponsorAccount, targetAccount, targetWorkspace, edition))) {
            return;
        }
        logger_1.default.info(`Successfully changed edition${workspaceNotice} of account ${chalk_1.default.blue(targetAccount)}.`);
    }
    catch (err) {
        logger_1.default.error(`Failed to change edition of account ${chalk_1.default.blue(targetAccount)}.`);
        throw err;
    }
    finally {
        if (autoSwitchBack) {
            await switch_1.returnToPreviousAccount({ previousAccount, previousWorkspace, promptConfirmation: false });
        }
        else {
            await switch_1.returnToPreviousAccount({ previousAccount, previousWorkspace });
        }
    }
}
exports.default = setEdition;
