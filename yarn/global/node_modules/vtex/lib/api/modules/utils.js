"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.continueAfterReactTermsAndConditions = exports.matchedDepsDiffTable = exports.formatNano = exports.yarnPath = exports.isLinked = exports.resolveAppId = exports.showBuilderHubMessage = exports.checkBuilderHubMessage = exports.getVendorFromApp = exports.appIdFromRegistry = exports.appLatestMajor = exports.appLatestVersion = exports.handleError = exports.pickLatestVersion = exports.extractVersionFromId = exports.wildVersionByMajor = exports.validateAppAction = exports.promptWorkspaceMaster = exports.workspaceProductionMessage = exports.workspaceMasterMessage = exports.sleepSec = void 0;
const tslib_1 = require("tslib");
const jsonwebtoken_1 = tslib_1.__importDefault(require("jsonwebtoken"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const diff_1 = require("diff");
const enquirer_1 = tslib_1.__importDefault(require("enquirer"));
const moment_1 = tslib_1.__importDefault(require("moment"));
const ramda_1 = tslib_1.__importStar(require("ramda"));
const semver_diff_1 = tslib_1.__importDefault(require("semver-diff"));
const Apps_1 = require("../clients/IOClients/infra/Apps");
const Registry_1 = require("../clients/IOClients/infra/Registry");
const Workspaces_1 = require("../clients/IOClients/infra/Workspaces");
const conf_1 = require("../conf");
const utils_1 = require("../error/utils");
const logger_1 = tslib_1.__importDefault(require("../logger"));
const manifest_1 = require("../manifest");
const SessionManager_1 = require("../session/SessionManager");
const table_1 = require("../table");
const prompts_1 = require("./prompts");
const Messages_1 = require("../constants/Messages");
const workspaceExampleName = process.env.USER || 'example';
const workspaceMasterAllowedOperations = ['install', 'uninstall'];
// It is not allowed to link apps in a production workspace.
const workspaceProductionAllowedOperatios = ['install', 'uninstall'];
const builderHubMessagesLinkTimeout = 2000; // 2 seconds
const builderHubMessagesPublishTimeout = 10000; // 10 seconds
exports.sleepSec = (sec) => new Promise(resolve => setTimeout(resolve, sec * 1000));
exports.workspaceMasterMessage = `This action is ${chalk_1.default.red('not allowed')} in workspace ${chalk_1.default.green('master')}, please use another workspace.
You can run "${chalk_1.default.blue(`vtex use ${workspaceExampleName} -r`)}" to use a workspace named "${chalk_1.default.green(workspaceExampleName)}"`;
exports.workspaceProductionMessage = workspace => `This action is ${chalk_1.default.red('not allowed')} in workspace ${chalk_1.default.green(workspace)} because it is a production workspace. You can create a ${chalk_1.default.yellowBright('dev')} workspace called ${chalk_1.default.green(workspaceExampleName)} by running ${chalk_1.default.blue(`vtex use ${workspaceExampleName} -r`)}`;
exports.promptWorkspaceMaster = async (account) => {
    const confirm = await prompts_1.promptConfirm(`Are you sure you want to force this operation on the ${chalk_1.default.green('master')} workspace on the account ${chalk_1.default.blue(account)}?`, false);
    if (!confirm) {
        return false;
    }
    logger_1.default.warn(`Using ${chalk_1.default.green('master')} workspace. I hope you know what you're doing. ðŸ’¥`);
    return true;
};
exports.validateAppAction = async (operation, app) => {
    const { account, workspace } = SessionManager_1.SessionManager.getSingleton();
    if (workspace === 'master') {
        if (!ramda_1.contains(operation, workspaceMasterAllowedOperations)) {
            throw utils_1.createFlowIssueError(exports.workspaceMasterMessage);
        }
        else {
            const confirm = await exports.promptWorkspaceMaster(account);
            if (!confirm) {
                return false;
            }
        }
    }
    const workspaces = Workspaces_1.createWorkspacesClient();
    const workspaceMeta = await workspaces.get(account, workspace);
    if (workspaceMeta.production && !ramda_1.contains(operation, workspaceProductionAllowedOperatios)) {
        throw utils_1.createFlowIssueError(exports.workspaceProductionMessage(workspace));
    }
    // No app arguments and no manifest file.
    const isReadable = await manifest_1.ManifestEditor.isManifestReadable();
    if (!app && !isReadable) {
        throw utils_1.createFlowIssueError(`No app was found, please fix your manifest.json${app ? ' or use <vendor>.<name>[@<version>]' : ''}`);
    }
    return true;
};
exports.wildVersionByMajor = ramda_1.compose(ramda_1.concat(ramda_1.__, '.x'), ramda_1.head, ramda_1.split('.'));
exports.extractVersionFromId = ramda_1.compose(ramda_1.last, ramda_1.split('@'));
exports.pickLatestVersion = (versions) => {
    const start = ramda_1.head(versions);
    return ramda_1.reduce((acc, version) => {
        return semver_diff_1.default(acc, version) ? version : acc;
    }, start, ramda_1.tail(versions));
};
exports.handleError = ramda_1.curry((app, err) => {
    if (err.response && err.response.status === 404) {
        return Promise.reject(utils_1.createFlowIssueError(`App ${chalk_1.default.green(app)} not found`));
    }
    return Promise.reject(err);
});
exports.appLatestVersion = (app, version = 'x') => {
    return Registry_1.createRegistryClient()
        .getAppManifest(app, version)
        .then(ramda_1.prop('id'))
        .then(exports.extractVersionFromId)
        .catch(exports.handleError(app));
};
exports.appLatestMajor = (app) => {
    return exports.appLatestVersion(app).then(exports.wildVersionByMajor);
};
exports.appIdFromRegistry = (app, majorLocator) => {
    return Registry_1.createRegistryClient()
        .getAppManifest(app, majorLocator)
        .then(ramda_1.prop('id'))
        .catch(exports.handleError(app));
};
exports.getVendorFromApp = (app) => {
    const [vendor] = app.split('.');
    return vendor;
};
async function checkBuilderHubMessage(cliRoute) {
    const http = axios_1.default.create({
        baseURL: `https://vtex.myvtex.com`,
        timeout: cliRoute === 'link' ? builderHubMessagesLinkTimeout : builderHubMessagesPublishTimeout,
    });
    try {
        const res = await http.get(`/_v/private/builder/0/getmessage/${cliRoute}`);
        return res.data;
    }
    catch (e) {
        return {};
    }
}
exports.checkBuilderHubMessage = checkBuilderHubMessage;
const promptConfirmName = (msg) => enquirer_1.default
    .prompt({
    message: msg,
    name: 'appName',
    type: 'input',
})
    .then(ramda_1.prop('appName'));
async function showBuilderHubMessage(message, showPrompt, manifest) {
    if (message) {
        if (showPrompt) {
            const confirmMsg = `Are you absolutely sure?\n${message ||
                ''}\nPlease type in the name of the app to confirm (ex: vtex.getting-started):`;
            const appNameInput = await promptConfirmName(confirmMsg);
            const AppName = `${manifest.vendor}.${manifest.name}`;
            if (appNameInput !== AppName) {
                throw utils_1.createFlowIssueError(`${appNameInput} doesn't match with the app name.`);
            }
        }
        else {
            logger_1.default.info(message);
        }
    }
}
exports.showBuilderHubMessage = showBuilderHubMessage;
exports.resolveAppId = (appName, appVersion) => {
    const apps = Apps_1.createAppsClient();
    return apps.getApp(`${appName}@${appVersion}`).then(ramda_1.prop('id'));
};
exports.isLinked = ramda_1.propSatisfies(ramda_1.contains('+build'), 'version');
exports.yarnPath = `"${require.resolve('yarn/bin/yarn')}"`;
exports.formatNano = (nanoseconds) => `${(nanoseconds / 1e9).toFixed(0)}s ${((nanoseconds / 1e6) % 1e3).toFixed(0)}ms`;
const formatAppId = (appId) => {
    const [appVendor, appName] = ramda_1.default.split('.', appId);
    if (!appName) {
        // Then the app is an 'infra' app.
        const [infraAppVendor, infraAppName] = ramda_1.default.split(':', appId);
        if (!infraAppName) {
            return appId;
        }
        return `${chalk_1.default.blue(infraAppVendor)}:${infraAppName}`;
    }
    return `${chalk_1.default.blue(appVendor)}.${appName}`;
};
const cleanVersion = (appId) => {
    return ramda_1.default.compose((version) => {
        const [pureVersion, build] = ramda_1.default.split('+build', version);
        return build ? `${pureVersion}(linked)` : pureVersion;
    }, ramda_1.default.last, ramda_1.default.split('@'))(appId);
};
exports.matchedDepsDiffTable = (title1, title2, deps1, deps2) => {
    const depsDiff = diff_1.diffArrays(deps1, deps2);
    // Get deduplicated names (no version) of the changed deps.
    const depNames = [
        ...new Set(ramda_1.default.compose(ramda_1.default.map(k => ramda_1.default.head(ramda_1.default.split('@', k))), ramda_1.default.flatten, ramda_1.default.pluck('value'), ramda_1.default.filter((k) => !!k.removed || !!k.added))(depsDiff)),
    ].sort((strA, strB) => strA.localeCompare(strB));
    const produceStartValues = () => ramda_1.default.map(_ => [])(depNames);
    // Each of the following objects will start as a { `depName`: [] }, ... }-like.
    const addedDeps = ramda_1.default.zipObj(depNames, produceStartValues());
    const removedDeps = ramda_1.default.zipObj(depNames, produceStartValues());
    // Custom function to set the objects values.
    const setObjectValues = (obj, formatter, filterFunction) => {
        ramda_1.default.compose(
        // eslint-disable-next-line array-callback-return
        ramda_1.default.map(k => {
            const index = ramda_1.default.head(ramda_1.default.split('@', k));
            obj[index].push(formatter(k));
        }), ramda_1.default.flatten, ramda_1.default.pluck('value'), ramda_1.default.filter(filterFunction))(depsDiff);
        ramda_1.default.mapObjIndexed((_, index) => {
            obj[index] = obj[index].join(',');
        })(obj);
    };
    // Setting the objects values.
    setObjectValues(removedDeps, k => chalk_1.default.red(`${cleanVersion(k)}`), (k) => !!k.removed);
    setObjectValues(addedDeps, k => chalk_1.default.green(`${cleanVersion(k)}`), (k) => !!k.added);
    const table = table_1.createTable(); // Set table headers.
    table.push(['', chalk_1.default.bold.yellow(title1), chalk_1.default.bold.yellow(title2)]);
    const formattedDepNames = ramda_1.default.map(formatAppId, depNames);
    // Push array of changed dependencies pairs to the table.
    Array.prototype.push.apply(table, ramda_1.default.map((k) => ramda_1.default.flatten(k))(ramda_1.default.zip(
    // zipping 3 arrays.
    ramda_1.default.zip(formattedDepNames, ramda_1.default.values(removedDeps)), ramda_1.default.values(addedDeps))));
    return table;
};
const REACT_BUILDER = 'react';
const EMAIL_KEY = 'sub';
const I_VTEX_ACCOUNT = '@vtex.com';
const BR_VTEX_ACCOUNT = '@vtex.com.br';
exports.continueAfterReactTermsAndConditions = async (manifest) => {
    const session = SessionManager_1.SessionManager.getSingleton();
    const { token } = session;
    const decodedToken = jsonwebtoken_1.default.decode(token);
    const userEmail = decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken[EMAIL_KEY];
    if (userEmail && (userEmail.endsWith(I_VTEX_ACCOUNT) || userEmail.endsWith(BR_VTEX_ACCOUNT))) {
        return true;
    }
    if (!Object.keys(manifest.builders).includes(REACT_BUILDER)) {
        return true;
    }
    const count = conf_1.getNumberOfReactLinks();
    if (count && count > 1) {
        return true;
    }
    conf_1.saveNumberOfReactLinks(count + 1);
    const now = moment_1.default();
    const lastShowDateString = conf_1.getLastLinkReactDate();
    if (lastShowDateString) {
        const lastShowDate = moment_1.default(lastShowDateString);
        console.log('lastShow', lastShowDate.toISOString());
        const elapsedTime = moment_1.default.duration(now.diff(lastShowDate));
        if (elapsedTime.asHours() < 24 && now.day() === lastShowDate.day()) {
            return true;
        }
    }
    logger_1.default.warn(Messages_1.reactTermsOfUse());
    const confirm = await prompts_1.promptConfirm(`Do you want to continue?`, false);
    if (confirm) {
        conf_1.saveLastLinkReactDate(now.toISOString());
    }
    return confirm;
};
