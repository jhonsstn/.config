"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const enquirer_1 = tslib_1.__importDefault(require("enquirer"));
const ramda_1 = require("ramda");
const modules_1 = require("../../api/modules");
const logger_1 = tslib_1.__importDefault(require("../../api/logger"));
const prompts_1 = require("../../api/modules/prompts");
const git = tslib_1.__importStar(require("./git"));
const SessionManager_1 = require("../../api/session/SessionManager");
const Messages_1 = require("../../lib/constants/Messages");
// Only show these templates for VTEX e-mail users.
const VTEXInternalTemplates = modules_1.FeatureFlag.getSingleton().getFeatureFlagInfo('VTEXInternalTemplates');
const templates = modules_1.FeatureFlag.getSingleton().getFeatureFlagInfo('templates');
const getTemplates = () => 
// Return all templates if user's e-mail is `...@vtex...`.
// Otherwise filter the VTEX internal templates.
ramda_1.test(/@vtex\./, SessionManager_1.SessionManager.getSingleton().userLogged)
    ? ramda_1.keys(templates)
    : ramda_1.reject(x => VTEXInternalTemplates.indexOf(x) >= 0, ramda_1.keys(templates));
const promptTemplates = async () => {
    const cancel = 'Cancel';
    const chosen = ramda_1.prop('service', await enquirer_1.default.prompt({
        name: 'service',
        message: 'Choose where do you want to start from',
        type: 'select',
        choices: [...getTemplates(), cancel],
    }));
    if (chosen === cancel) {
        logger_1.default.info('Bye o/');
        return process.exit();
    }
    return chosen;
};
const promptContinue = async (repoName, projectFolderName) => {
    const proceed = await prompts_1.promptConfirm(Messages_1.Messages.PROMPT_CONFIRM_NEW_FOLDER(`${process.cwd()}/${projectFolderName !== null && projectFolderName !== void 0 ? projectFolderName : repoName}`));
    if (!proceed) {
        logger_1.default.info('Bye o/');
        process.exit();
    }
};
exports.default = async (projectFolderName) => {
    logger_1.default.debug(Messages_1.Messages.DEBUG_PROMPT_APP_INFO);
    logger_1.default.info(Messages_1.Messages.INIT_HELLO_EXPLANATION());
    try {
        const { repository: repo, organization: org } = templates[await promptTemplates()];
        await promptContinue(repo, projectFolderName);
        logger_1.default.info(`Cloning ${chalk_1.default.bold.cyan(repo)} from ${chalk_1.default.bold.cyan(org)}.`);
        await git.clone(repo, org, projectFolderName);
        logger_1.default.info(Messages_1.Messages.INIT_START_DEVELOPING(projectFolderName !== null && projectFolderName !== void 0 ? projectFolderName : repo));
    }
    catch (err) {
        logger_1.default.error(err.message);
        logger_1.default.debug(err);
    }
};
