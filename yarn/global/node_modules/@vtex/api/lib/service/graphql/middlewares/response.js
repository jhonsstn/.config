"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
const constants_1 = require("../../../constants");
const cacheControl_1 = require("../utils/cacheControl");
const DEV_FIELDS = ['data', 'errors', 'extensions'];
const PROD_FIELDS = ['data', 'errors'];
function setVaryHeaders(ctx, scope, segment) {
    ctx.vary(constants_1.FORWARDED_HOST_HEADER);
    if (segment) {
        ctx.vary(constants_1.SEGMENT_HEADER);
    }
    if (scope === 'private' || ctx.query.scope === 'private') {
        ctx.vary(constants_1.SESSION_HEADER);
    }
    else if (ctx.vtex.sessionToken) {
        ctx.vtex.logger.warn({
            message: 'GraphQL resolver receiving session token without private scope',
            userAgent: ctx.get('user-agent'),
        });
    }
}
async function response(ctx, next) {
    const { responseInit, graphqlResponse } = ctx.graphql;
    const { production } = ctx.vtex;
    const { maxAge = '', scope = '', segment = null, } = graphqlResponse ? cacheControl_1.cacheControl(graphqlResponse, ctx) : {};
    const cacheControlHeader = ramda_1.reject(ramda_1.isEmpty, [maxAge, scope]).join(',');
    ctx.set(Object.assign({}, responseInit && responseInit.headers, { 'Cache-Control': cacheControlHeader }));
    if (ctx.method.toUpperCase() === 'GET') {
        setVaryHeaders(ctx, scope, segment);
    }
    const fields = production ? PROD_FIELDS : DEV_FIELDS;
    ctx.body = ramda_1.pick(fields, graphqlResponse);
    await next();
}
exports.response = response;
