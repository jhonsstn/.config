"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Messages_1 = require("../lib/constants/Messages");
const axios_1 = tslib_1.__importDefault(require("axios"));
const boxen_1 = tslib_1.__importDefault(require("boxen"));
const ora_1 = tslib_1.__importDefault(require("ora"));
const vtex_1 = require("vtex");
const { checkForConflicts } = vtex_1.VBase.createClient();
const { promote, get } = vtex_1.createWorkspacesClient();
const { account, workspace: currentWorkspace } = vtex_1.SessionManager.getSingleton();
const workspaceUrl = vtex_1.authUrl();
const throwIfIsMaster = (workspace) => {
    if (workspace === 'master') {
        throw vtex_1.createFlowIssueError(Messages_1.Messages.PROMOTE_MASTER_ERROR(workspace));
    }
};
const handleConflict = async () => {
    const conflictsFound = await checkForConflicts();
    if (conflictsFound) {
        await axios_1.default.get(workspaceUrl);
    }
};
const isPromotable = async (workspace) => {
    const spinner = ora_1.default(Messages_1.Messages.PROMOTE_SPINNER_START).start();
    spinner.color = vtex_1.COLORS.MAGENTA;
    throwIfIsMaster(workspace);
    const meta = await get(account, currentWorkspace);
    if (!meta.production) {
        throw vtex_1.createFlowIssueError(Messages_1.Messages.PROMOTE_NOT_PRODUCTION_ERROR(workspace));
    }
    await handleConflict();
    spinner.succeed();
};
const parseInternalBucket = (internalBucket) => {
    const [vendor, app, bucket] = internalBucket.split('.');
    return bucket != null ? Messages_1.Messages.CONFLICTING_BUCKET_DESCRIPTOR(bucket, `${vendor}.${app}`) : null;
};
const parseConflictMessage = (message) => {
    const [, buckets] = message.split(':');
    const internalBuckets = buckets.split(',').map((bucket) => bucket.trim());
    return internalBuckets.map(parseInternalBucket).filter((bucket) => bucket != null);
};
const handleConflictOnPromote = (workspace, e) => {
    var _a;
    if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) !== 409)
        throw e;
    const buckets = parseConflictMessage(e.response.data.message);
    console.log(Messages_1.Messages.PROMOTE_CONFLICT_ERROR(workspace, buckets));
};
const handlePromoteSuccess = async () => {
    vtex_1.logger.info(Messages_1.Messages.PROMOTE_SUCCESS(currentWorkspace));
    console.log(boxen_1.default(Messages_1.Messages.PROMOTE_ASK_FEEDBACK, {
        padding: 1,
        margin: 1,
    }));
    await vtex_1.workspaceUse('master');
};
const promptPromoteConfirm = (workspace) => vtex_1.promptConfirm(Messages_1.Messages.PROMOTE_PROMPT_CONFIRM(workspace), true);
exports.default = async (conflictResolutionStrategy) => {
    vtex_1.logger.debug(Messages_1.Messages.PROMOTE_INIT, currentWorkspace);
    await isPromotable(currentWorkspace);
    console.log(Messages_1.Messages.PROMOTE_CHECK_WORKSPACE(currentWorkspace, workspaceUrl));
    const promptAnswer = await promptPromoteConfirm(currentWorkspace);
    if (!promptAnswer) {
        vtex_1.logger.info(Messages_1.Messages.PROMOTE_PROMPT_NEGATIVE_ANSWER(currentWorkspace));
        return;
    }
    await promote(account, currentWorkspace, conflictResolutionStrategy)
        .then(handlePromoteSuccess)
        .catch((e) => handleConflictOnPromote(currentWorkspace, e));
};
