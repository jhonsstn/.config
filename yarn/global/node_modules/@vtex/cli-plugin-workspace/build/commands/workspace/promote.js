"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const promote_1 = tslib_1.__importDefault(require("../../modules/promote"));
const vtex_1 = require("vtex");
const conflictFlagMapping = {
    master: 'MasterWins',
    mine: 'MineWins',
    abort: 'Abort',
};
const conflictFlagDescription = [
    `Defines how to handle data conflict between ${vtex_1.ColorifyConstants.ID('workspaces')}.`,
    `- master: Discards the ${vtex_1.ColorifyConstants.ID(`workspace's`)} conflicting data, keeping the data from master unchanged.`,
    `- mine: Overrides the master with the specified ${vtex_1.ColorifyConstants.ID('workspace')}. Any conflicting data on the master is lost.`,
    `- abort: Aborts the ${vtex_1.ColorifyConstants.ID('workspace')} promotion in case of data conflict.`,
].join('\n');
const conflictResolutionFlag = command_1.flags.string({
    description: conflictFlagDescription,
    options: ['master', 'mine', 'abort'],
    default: 'master',
});
class WorkspacePromote extends vtex_1.CustomCommand {
    async run() {
        const { flags: { conflict }, } = this.parse(WorkspacePromote);
        await promote_1.default(conflictFlagMapping[conflict]);
    }
}
exports.default = WorkspacePromote;
WorkspacePromote.description = `Promotes the current ${vtex_1.ColorifyConstants.ID('workspace')} to master. (Only works for ${vtex_1.ColorifyConstants.ID('production workspaces')}.) Run ${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF('vtex promote --help')} to see how to deal with data conflicts.`;
WorkspacePromote.aliases = ['promote'];
WorkspacePromote.examples = [
    `${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF('vtex workspace promote')}`,
    `${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF('vtex promote')}`,
];
WorkspacePromote.flags = {
    ...vtex_1.CustomCommand.globalFlags,
    conflict: conflictResolutionFlag,
};
WorkspacePromote.args = [];
