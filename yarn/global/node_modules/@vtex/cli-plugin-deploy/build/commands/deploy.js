"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const vtex_1 = require("vtex");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const oldDeploy_1 = tslib_1.__importDefault(require("../modules/oldDeploy"));
const newDeploy_1 = tslib_1.__importDefault(require("../modules/newDeploy"));
class Deploy extends vtex_1.CustomCommand {
    async run() {
        const configClient = vtex_1.ToolbeltConfig.createClient();
        const { featureFlags } = await configClient.getGlobalConfig();
        if (featureFlags.FEATURE_FLAG_DEPLOY_PLUGIN) {
            const { args: { appId }, flags: { yes, force }, } = this.parse(Deploy);
            await newDeploy_1.default(appId, { yes, force });
        }
        else {
            const { args: { appId }, flags: { yes }, } = this.parse(Deploy);
            await oldDeploy_1.default(appId, { yes });
        }
    }
}
exports.default = Deploy;
Deploy.description = `Publishes an app as a stable version. Only works for apps previously published as a release candidate [see ${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF('vtex publish --help')}].`;
Deploy.examples = [
    `${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF('vtex deploy')}`,
    `${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF('vtex deploy')} vtex.service-example@0.0.1`,
];
Deploy.flags = {
    ...vtex_1.CustomCommand.globalFlags,
    yes: command_1.flags.boolean({ char: 'y', description: 'Answers yes to all prompts.' }),
    force: command_1.flags.boolean({
        char: 'f',
        description: `Ignores the testing period of 7 minutes after publishing an app. ${chalk_1.default.yellow('(Use with caution.)')}`,
    }),
};
Deploy.args = [
    {
        name: 'appId',
        description: `Name and version of the app ${vtex_1.ColorifyConstants.ID('({vendor}.{appname}@{x.x.x})')} you want to deploy.`,
    },
];
