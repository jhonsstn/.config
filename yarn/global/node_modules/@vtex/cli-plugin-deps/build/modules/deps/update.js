"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const diff_1 = require("diff");
const ramda_1 = require("ramda");
const vtex_1 = require("vtex");
const utils_1 = require("./utils");
const Messages_1 = require("../../lib/constants/Messages");
const { getDependencies, updateDependencies, updateDependency } = vtex_1.createAppsClient();
exports.default = async (optionalApps) => {
    const appsList = optionalApps.filter((arg) => arg && arg !== '');
    try {
        vtex_1.logger.debug(Messages_1.Messages.DEPS_UPDATE_INIT_PROCESS);
        const previousDeps = await getDependencies();
        let currentDeps;
        if (appsList.length === 0) {
            currentDeps = await updateDependencies();
        }
        else {
            for (const locator of appsList) {
                const { vendor, name, version } = vtex_1.parseLocator(locator);
                if (!name || !version) {
                    vtex_1.logger.error(Messages_1.Messages.DEPS_UPDATE_INVALID_FORMAT_ERROR(locator));
                }
                else {
                    try {
                        vtex_1.logger.debug(Messages_1.Messages.DEPS_UPDATE_INIT(locator));
                        // eslint-disable-next-line no-await-in-loop
                        await updateDependency(`${vendor}.${name}`, version, vendor);
                    }
                    catch (e) {
                        vtex_1.logger.error(e.message);
                        if (ramda_1.path(['response', 'data', 'message'], e)) {
                            vtex_1.logger.error(e.response.data.message);
                        }
                    }
                }
            }
            currentDeps = await getDependencies();
        }
        const [cleanPrevDeps, cleanCurrDeps] = ramda_1.map(utils_1.cleanDeps, [previousDeps, currentDeps]);
        const diff = diff_1.diffJson(cleanPrevDeps, cleanCurrDeps);
        let nAdded = 0;
        let nRemoved = 0;
        diff.forEach(({ count = 0, value, added, removed }) => {
            const color = added ? chalk_1.default.green : removed ? chalk_1.default.red : chalk_1.default.gray;
            if (added) {
                nAdded += count;
            }
            else if (removed) {
                nRemoved += count;
            }
            process.stdout.write(color(value));
        });
        if (nAdded === 0 && nRemoved === 0) {
            vtex_1.logger.info(Messages_1.Messages.DEPS_UPDATE_EMPTY);
        }
        else {
            if (nAdded > 0) {
                vtex_1.logger.info('', nAdded, nAdded > 1 ? ' dependencies ' : ' dependency ', chalk_1.default.green('added'), ' successfully');
            }
            if (nRemoved > 0) {
                vtex_1.logger.info('', nRemoved, nRemoved > 1 ? ' dependencies ' : 'dependency ', chalk_1.default.red('removed'), ' successfully');
            }
        }
    }
    catch (e) {
        vtex_1.logger.error(e.message);
        if (ramda_1.path(['response', 'data', 'message'], e)) {
            vtex_1.logger.error(e.response.data.message);
        }
    }
};
