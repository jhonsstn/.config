"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const plugins_1 = tslib_1.__importDefault(require("../../modules/plugins"));
const vtex_1 = require("vtex");
class PluginsUninstall extends command_1.Command {
    constructor() {
        super(...arguments);
        this.plugins = new plugins_1.default(this.config);
    }
    // In this case we want these operations to happen
    // sequentially so the `no-await-in-loop` rule is ugnored
    /* eslint-disable no-await-in-loop */
    async run() {
        const { flags, argv } = this.parse(PluginsUninstall);
        this.plugins = new plugins_1.default(this.config);
        if (flags.verbose)
            this.plugins.verbose = true;
        if (argv.length === 0)
            argv.push(".");
        for (const plugin of argv) {
            const friendly = this.removeTags(this.plugins.friendlyName(plugin));
            cli_ux_1.default.action.start(`Uninstalling ${friendly}`);
            const unfriendly = await this.plugins.hasPlugin(this.removeTags(plugin));
            if (!unfriendly) {
                const p = this.config.plugins.find((p) => p.name === plugin);
                if (p) {
                    if (p && p.parent)
                        return this.error(`${friendly} is installed via plugin ${p.parent.name}, uninstall ${p.parent.name} instead`);
                }
                return this.error(`${friendly} is not installed`);
            }
            try {
                await this.plugins.uninstall(unfriendly.name);
            }
            catch (error) {
                cli_ux_1.default.action.stop(chalk_1.default.bold.red("failed"));
                throw error;
            }
            cli_ux_1.default.action.stop();
        }
    }
    /* eslint-enable no-await-in-loop */
    removeTags(plugin) {
        if (plugin.includes("@")) {
            const chunked = plugin.split("@");
            const last = chunked[chunked.length - 1];
            if (!last.includes("/") && chunked.length > 1) {
                chunked.pop();
            }
            return chunked.join("@");
        }
        return plugin;
    }
}
exports.default = PluginsUninstall;
PluginsUninstall.description = "Removes a plugin from the CLI";
PluginsUninstall.usage = "plugins uninstall PLUGIN";
PluginsUninstall.help = `${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF("vtex plugins uninstall")} autoupdate`;
PluginsUninstall.variableArgs = true;
PluginsUninstall.args = [{ name: "plugin", description: "Plugin to uninstall." }];
PluginsUninstall.flags = {
    help: command_1.flags.help({ char: "h" }),
    verbose: command_1.flags.boolean({ char: "v" }),
};
PluginsUninstall.aliases = ["plugins:unlink", "plugins:remove"];
