"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const chalk = require("chalk");
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const vtex_1 = require("vtex");
const vtex_2 = require("vtex");
const plugins_1 = tslib_1.__importDefault(require("../../modules/plugins"));
class PluginsInstall extends command_1.Command {
    constructor() {
        super(...arguments);
        this.plugins = new plugins_1.default(this.config);
    }
    // In this case we want these operations to happen
    // sequentially so the `no-await-in-loop` rule is ugnored
    /* eslint-disable no-await-in-loop */
    async run() {
        const { flags, argv } = this.parse(PluginsInstall);
        if (flags.verbose)
            this.plugins.verbose = true;
        const aliases = this.config.pjson.oclif.aliases || {};
        for (let name of argv) {
            if (aliases[name] === null)
                this.error(`${name} is blocked`);
            name = aliases[name] || name;
            const p = await this.parsePlugin(name);
            let plugin;
            await this.config.runHook("plugins:preinstall", {
                plugin: p,
            });
            try {
                const pluginsAllowList = vtex_2.FeatureFlag.getSingleton().getFeatureFlagInfo('PLUGINS_ALLOW_LIST');
                if (p.type === 'npm') {
                    this.ensureNpmPackageScopeIsAllowed(p.name, pluginsAllowList.allowedNpmScopes);
                    this.ensurePluginFollowsStandardPattern(p.name);
                    cli_ux_1.default.action.start(`Installing plugin ${chalk.cyan(this.plugins.friendlyName(p.name))}`);
                    plugin = await this.plugins.install(p.name, {
                        tag: p.tag,
                        force: flags.force,
                    });
                }
                else {
                    this.ensureGitOrgIsAllowed(p.url, pluginsAllowList.allowedGitOrgs);
                    this.ensurePluginFollowsStandardPattern(p.url);
                    cli_ux_1.default.action.start(`Installing plugin ${chalk.cyan(p.url)}`);
                    plugin = await this.plugins.install(p.url, { force: flags.force });
                }
            }
            catch (error) {
                cli_ux_1.default.action.stop(chalk.bold.red("failed"));
                throw error;
            }
            cli_ux_1.default.action.stop(`installed v${plugin.version}`);
        }
    }
    /* eslint-enable no-await-in-loop */
    async parsePlugin(input) {
        if (input.startsWith('git+ssh://') || input.endsWith('.git')) {
            return { url: input, type: 'repo' };
        }
        if (input.includes("@") && input.includes("/")) {
            input = input.slice(1);
            const [name, tag = "latest"] = input.split("@");
            return { name: "@" + name, tag, type: "npm" };
        }
        if (input.includes("/")) {
            if (input.includes(":"))
                return { url: input, type: "repo" };
            return { url: `https://github.com/${input}`, type: "repo" };
        }
        const [splitName, tag = "latest"] = input.split("@");
        const name = await this.plugins.maybeUnfriendlyName(splitName);
        return { name, tag, type: "npm" };
    }
    ensureNpmPackageScopeIsAllowed(name, allowedNpmScopes) {
        if (!allowedNpmScopes.some(npmScope => name.startsWith(npmScope))) {
            this.error(this.notAllowedPluginErrorMessage(name));
        }
    }
    ensureGitOrgIsAllowed(url, allowedGitOrgs) {
        if (!allowedGitOrgs.some(gitOrg => url.includes(gitOrg))) {
            this.error(this.notAllowedPluginErrorMessage(url));
        }
    }
    ensurePluginFollowsStandardPattern(identifier) {
        if (!identifier.includes('cli-plugin-')) {
            this.error('All toolbelt plugins need to follow the naming convention "cli-plugin-{pluginName}"');
        }
    }
    notAllowedPluginErrorMessage(identifier) {
        return `Only plugins from a restricted list of vendors are allowed to be installed. ${identifier} is not allowed.`;
    }
}
exports.default = PluginsInstall;
PluginsInstall.description = "Installs a plugin into the CLI.";
PluginsInstall.usage = "plugins install PLUGIN";
PluginsInstall.examples = [
    `${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF("vtex plugins install")} lighthouse`,
    `${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF("vtex plugins install")} ${chalk.hex(vtex_1.COLORS.BLUE)("https://github.com/vtex/cli-plugin-someplugin")}`,
    `${vtex_1.ColorifyConstants.COMMAND_OR_VTEX_REF("vtex plugins install")} @vtex/cli-plugin-someplugin`,
];
PluginsInstall.strict = false;
PluginsInstall.args = [
    { name: 'plugin', description: 'plugin to install', required: true },
];
PluginsInstall.flags = {
    help: command_1.flags.help({ char: "h" }),
    verbose: command_1.flags.boolean({ char: "v" }),
    force: command_1.flags.boolean({
        char: "f",
        description: "Refetches all packages, even the ones that were previously installed.",
    }),
};
PluginsInstall.aliases = ['plugins:add'];
